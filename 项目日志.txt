


cd..
cd router
cd strip_getter
cd router_vuestyle
npm run dev
npm run build



------------当前任务笔记------------

 


1. 导航条过短应改变
1. 导航条有几率出现BUG:在非首页页面触发了首页页面的效果
1. 路由动效
1. 输入取值改变




-----------------------------------




-------------------待完成目标-------------------


-1、配置路由
    ① 确定“分配时间类型”后带数据进入“分配时间”页面
      【这个功能待拆除】

0、首页
   ① 排行榜
   ② banner
   ③ 备忘录功能？【不急】

1、“分配时间”页面
   ① 任务分块功能【不急】
     能用加号或者两种分号来达到目的【不急】
   ② 点击“分配完成”后将totalSubmission.allocateTime_total数据做好
   ③ 点击“分配完成”后自动将最后一个任务后的时间切掉【完成】
   ④ 增加时长选项，追踪时间页面也加上【完成】
     最后一个拖拽条的时长选项可以输入，输入的数值就是时长【完成】
   ⑤ 可以设置拖拽条wrap的dom宽度，“追踪时间”页面也一样【完成】
   ⑥ 可以修改时间段名称【不急】

2、“追踪时间”页面
   ① 显示的是时间而不是时间长度【已做了一个临时方案】
     进入第二三天后天数名称自动更改【不急】
   ② 会有一个指针跟随时间走动【完成】
   ③ 判断正在进行的任务会特别显示【完成】
     并且可以对其使用两个按钮：提早完成/完成、延长该段时间【完成】
     点击 完成 自动调整各拖拽条位置【完成】
     如果过了最后一个时间段的时间并且没有点击完成，则最后一段时间自动进入延长状态【完成】【】可以考虑让这几个延长状态、暂停状态共用一部分代码
   ④ 若有三个任务没有调整时间，且过了半分钟，则从第三个任务后就改为 暂停状态 。【不急】
     如果这半分钟内触碰到第四个任务，则把第四个任务移至暂停后。并提示暂停原因【不急】
   ⑤ “临时暂停”按钮【】
     （暂停后自动延长后续任务时间，所有拖拽条自动缩短）
     （暂停的时间点也要保存）
     如果'在index上'且距离首或尾不足5秒，则应特殊处理【不急】
                     首尾长度不足9秒，则应改为已删除状态【不急】
     （辅助信息：在index上:timeAfterBeginTracking>=begin+2 &&timeAfterBeginTracking<end
                在index后:timeAfterBeginTracking>=end）
   ⑥ 可以做一个进度条，用来显示当前任务状态【不急】
     或者到下个任务的倒计时【不急】
   ⑦ 完成状态有几种：未完成、进行中、已完成、未确认、已删除
   已完成状态的拖拽条不可以被改动【不急】
开始前数据和结束后数据都将保留
结束后提示免费注册，注册后拥有云记录功能和个人页面，可以多端共享记录


    ⑧ 已花时间和剩余时间

3. “追踪完成”页面
“追踪时间”页面完成后显示
页面上显示内容如下：
    1. 原计划分配的时间
       【BUG】
       在“追踪时间”页面上，totalSubmission.allocateTime_total会随s.dragBar改变
       做了一些测试，发现是由序号1的测试结果导致的问题，但不知道为何序号1的测试会有这个结果。
	   测试内容如下：
        1. 测试：写一个mutation：`s.test=s.dragBar`
           不管放在分配时间页面还是追踪时间页面s.dragBar变化后s.test都会跟着变化
           （测试于实际项目）
        2. 测试：s.object.a=this.getters.getterOfStateA（state a的getter），改变s.a，后会不会导致s.object.a改变？（一个逗号一个mutation）
           答案是 不会
           （测试于实际项目）
        3. 测试：mutation s.object.a=s.b，s.object.b=this.getters.a后，改变s.b，会不会导致s.a改变？（一个逗号一个mutation）
           答案是 不会
           结果与实际项目相悖
           （测试于vuecli2项目）
        4. 测试：mutation s.a=s.b后，s.b改变会不会导致s.a改变？
           答案是 不会
           结果与实际项目相悖
           （测试于vuecli2项目）
        也已经试验关闭了路由的history模式、用Vue.set()来设置属性、改变了各state的初始值，依旧存在这个BUG
    2. 实际完成的时间

4、“个人展示”页面
数据的展示，需展示信息如下：
    1. 每一次时间记录的展示，需要内容如下：
        1. 原计划分配的时间
           BUG未解决，与另一个BUG为同一个BUG：“追踪完成”页面.原计划分配的时间
        2. 实际完成的时间


5、帐号
   ① 登出功能
     登出后不发送数据
   ② 可以给别人指定任务
   ③ 可以保证浏览器关了后再开，效果和没关一样
     多端数据同步，在一个端操作后，另一端打开效果一样
   ④ 可以预置分配时间模板，点击模板自动分配

6、外观修整
	1. 第一步调整【待完成】
	   （2018.02.25）
	    1. 动效分布均匀
	    2. 区块分好、层级合理
	    3. 要有成熟的商业网站气息
	    4. 高端大气上档次
	    5. 能吸引新用户来用
	2. 第二步调整【不急】
	   （个人兴趣驱使的产物，可能并不符合市场）
		1. 配色可自由修改
		 并送上四套我做的配色：热血、清寡、高端科技、粉红少女
		2. 壁纸功能

7、特色功能【不急】
   ① 给定事件是否达到指定时长的功能（可以设置总项也可以设置时间段）
   ② 可以给事件（总项或时间段）设置闹钟也可以不设
     闹钟可以选择提早多少时间响起
     可以方便地在时间段末尾添加闹钟，有声音的
   ③ 固定时间段
     起始结束时间都以钟表时间为准
     非固定时间段会从固定时间段上跨越过去（有时会被分为多段）
   ④ 常规时间
     按周期自动添加的时间，周期可以是天、周、两周、月
   ⑤ 常规闹钟
     类似“常规时间”，但是是闹钟
     可以选择提醒方式：响到点击为止、响几秒、不响
   ⑥ 备注
     不论是闹钟还是时间段，都可以添加100字内备注
   ⑥ 待完成事项
     可以选择完成时间范围，可以选择需要做的次数或者时长
     在“分配时间”页面可以很方便地添加
   ⑧ “追踪时间”页面按钮
     让其根据情况显示或者不显示
     增加删除时间段按钮

8、会员【不急】
   ① 价格：120元/年
   ② 评论图片按帐号储存，普通帐号图库不超过1MB，会员则拥有66.6MB
   ③ 会员的壁纸可以存到云端，与评论图片共享空间
   ④ 网站的每一个页面都可以留言，但是非评论区页面只有会员可以留言，一个页面一个会员可以留一条。点赞最高的三条会在第一屏展示，其余的要滚动或者打开全部查看。会员失效后其留言也会消失。
   ⑤ 拥有会员徽章，总共充过几年会员就会获得几年的会员徽章，以及小于这个数值的所有会员徽章，可以选择其中一个佩戴，也可以选择不佩戴。会员失效后所有会员徽章撤销。
   ⑥ 可以让自己的评论变色或者加粗，甚至给自己的评论加上背景图
   ⑦ 可以删除自己的评论
   ⑧ 普通帐号只能选择展示或者不展示自己的时间，而会员可以选择部分展示，而部分不展示
   ⑨ 会员的建议将作为网站修改的重要参考

9、评论功能

10、录制视频：为什么选择《进化论・时间管理者》、
         操作教学、
         会员系统


----------------------------------------------




------------代码结构可优化点记录------------


1、引入自定义指令的重命名（易）
2、一些没用的备注信息删掉（易）
3、dragBarP1 getter中去掉show属性
4、新建拖拽条时会自动在dragBarP1 getter中计算百分比【完成】
5、dragBarP1 getter可能可以用filter来写【看完后感觉不是一个好主意】
6、drag.js中除了leftHandle、bg.onmousedown以外的代码都已梳理清楚做好了备注
   点击触发函数内的代码也可以梳理一下（易）
   尤其是bg.onmousedown > EntireDragBarPutRight(l) > maxLeft
   因为 maxLeft 在目前脚本中只在bind中改变，有可能出现问题，不过目前没测试出问题
7、strip_getter文件夹内容其实和router文件夹中稍有差异，有空以router文件夹为标准改好（易）
8、drag.js及相关vuex备注的修改（易）
9、整理functions.js（易）
10、研究lastDragbarTimeLength能否用及时响应模式（getter之类）代替用mutation来更新其值。
    这样的话数值会即使反应出来，而且可以减少mutation代码，和调试工具中的mutation事件
11、BUG：拖拽条bg长度有时候过长
         如 分配时间 页面用输入的方法 调整时间长度过短时
		    追踪时间 页面点击完成按钮 调整时间长度过短时
		 有可能是vue计算结果为负数时不输出导致的
12、BUG：延时完成 有一半几率导致后一个时间是进行中
         最外层文件夹上有放原因图解
         暂时通过在loop_trackingTimePage中-1秒的方法绕开了
13、BUG：删掉拖拽条后再添加拖拽条。不能使用键入的方式改变长度
         细节：删掉后一个拖拽条后，前一个拖拽条时间长度会变为 删掉拖拽条 的长度，但是起始、结束点不会变化
14、“最后一段时间自动进入延长状态”的优化
    考虑最后一个拖拽条结尾可能不在拖拽条外套末端的情况
    可以考虑把延长timeLength这种任务交给其他部分代码
15、把functions.js中的GetNextDragbar()改为GetDragbarP1()
    功能从获取dragbarP1的下一个元素变成获取dragbarP1中的任意元素
16、BUG：延时完成状态下 还未到结束时间时，点击完成和暂停都会有BUG
17、突发事件暂停不应该有操作按钮



-------------------------------------------




------------没负面影响但是很奇怪的点------------


・  条状取值器（strip_getter）
1、state子项dragBar会拥有以其为原形的getter的属性
   原因可能是没有使用vue.set()等专用的对象增加方法
   但是这一点不需要优化，可以方便其它代码的书写
2、vue-devtools components选项卡中的vuex数据不知如何理解
3、构建的vue似乎无法用 实例名. 这种方法在控制台操作


・ router_vuestyle文件夹
1、drag.js里触发函数中可以把dom数据返回给mutation，而非触发函数不仅不行，还会导致拖拽条left、right都为0，且bg宽度无设置


----------------------------------------------



------------连接服务器变成动态网站 逻辑文档------------


主、次要目标与“要发送的数据 逻辑文档”相同

需要功能：注册、登录、登出、提交数据、提取数据


需要数据：
帐号：手机、用户ID、用户名、密码、签名、头像、注册时间、密保问题及答案三个、性别、生日、城市、工作、专业
时间记录：每次提交的时间总数据


----------------------------------------------------



------------要发送的数据 逻辑文档------------


要提交的数据要达成的首要目的：
记录下计划的时间与实际完成的时间，方便在结束页面或者未来做数据分析
要提交的数据要达成的次要目的：
关闭网页后再开也能恢复原状


需要元素：
时间类型、计划的时间、beginTrackingTime、
实际完成的时间（如果对其的每个操作都能实时ajax到服务器最好）、
是否成功完成



-------------------------------------------



------------临时暂停 按钮 逻辑文档------------



临时暂停有几种情况：
a、时间指针还没碰到拖拽条
      即最前显示的拖拽条的begin>=时间指针
      应该操作的dragBar序号：dragBarP1[0]的timeSlotId
                           （由于用timeSlotId当dragBar序号选元素都会选到该timeSlotId最前面的一个，所以这种情况可以用，其他情况用dragBarP1[0]的timeSlotId须谨慎）
      判断方法：比较dragBarP1[0]与时间指针，得出结果
b、时间指针在拖拽条上，且拖拽条有宽度
      即有一个拖拽条的begin<时间指针且end>时间指针
      应该操作的dragBar序号：这个拖拽条的序号
      判断方法：遍历dragBar，符合这个条件则提取出数据
d、时间指针 在状态不为“延迟完成”的拖拽条末尾（包括拖拽条begin、end相等的情况） 或者 不在非暂停中拖拽条上但前面有拖拽条
      应该操作的dragBar序号：这个拖拽条的序号
      判断方法：
          即遍历时算出小于等于时间指针的最大的begin，如果begin最大的拖拽条的end<=时间指针 且该拖拽条状态不为'延迟完成'
          或者第二大begin的拖拽条满足这个情况
          则说明是该情况
f、'前一个显示的拖拽条的状态是“延迟完成”，且end等于时间指针'
   和
   '前一个显示的拖拽条的状态是“延迟完成”，且end比时间指针小一秒'
      即有一个拖拽条的begin<=时间指针，end等于时间指针 或者 end等于时间指针-1秒，status是'延迟完成'
      应该操作的dragBar序号：这个拖拽条的序号
      判断方法：① 遍历dragBar，符合这个条件 则是这种情况
               ② 遍历时算出小于等于时间指针的最大的begin，如果这个begin所在dragBar或者begin第二大的dragBar符合这个条件 则是这种情况
                 （因为当“时间指针大于延迟拖拽条end且后面紧跟着一个拖拽条”时最大begin所在的拖拽条会变成延迟拖拽条的后一个拖拽条。当然，如果时间指针超出的一秒内有不止1个begin的话判断第二大的也会出BUG，但是这种情况就很偏了，暂时不考虑）
                 【采用，因为前面始终要先取出这个dragBar，所以用这个方法有几率少做一次遍历】


处理有几种方法：
1、a：若还未碰到过拖拽条，则在第一个 存在的 拖拽条前 加入'延迟完成'状态的 临时暂停 拖拽条
2、b：把拖拽条分为两部分，并且在其中间 加入'延迟完成'状态的 临时暂停 拖拽条
3、d：判断出时间指针处于哪个拖拽条后面，在其后 加入'延迟完成'状态的 临时暂停 拖拽条
4、f：若在暂停状态中，则解除暂停状态。即运行暂停拖拽条的“完成”按钮，即FinishTimeSlot(s,应该操作的拖拽条)
      若不是暂停拖拽条，那还应该在后面加上暂停拖拽条
（这些拖拽条包括暂停拖拽条，但是执行把暂停拖拽条分开时要报错）


注意点：
时间指针会领先拖拽条端点0-1秒
外在表现：时间指针有时会超过 '延时完成'的end一秒




---------------------------------------




-----------数据结构-----------


・ “时间段”正确翻译是 Time slot


・ 最终要得到的两个数据（最终都要合到一个对象下）
这两个数据的格式：
各个时间点（暂定）都用时间戳保存
分别需要的时间点：
1、分配时间
   总分配时间的两端的时间戳、各拖拽条两端的时间戳
2、追踪时间（除了总分配时间左端以外每个时间点都有可能与‘分配时间’不同）
   总分配时间的两端的时间戳、各拖拽条两端的时间戳、暂停时间段两端的时间戳
3、分配完毕的时间戳、时间
得到的时机：
1、分配时间、分配完毕的时间戳、时间
   点击‘分配完毕’后
2、追踪时间
   点击‘完成’


・ 点击‘分配完毕’后要设置的函数
根据分配完毕的时间戳，当到达第二、三天时，名称改变【不急】


・ （猜测）运行中也需要的数据
1、分配时间运行数据（目前已有）

2、追踪时间运行数据（未增加，需增加。且在点击‘分配完毕’后）
   在点击‘分配完毕’后需加入的数据：
       ① 时间化的节点


----------------------------














